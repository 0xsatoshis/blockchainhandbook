# 区块链技术与应用小白书

[胡成武](https://github.com/Colinhuu)（著）&copy; 2019

《区块链技术与应用小白书》-小白也能懂的区块链技术书

-----
## 引言

2019年10月24日[习近平在中央政治局第十八次集体学习时强调把区块链作为核心技术自主创新重要突破口](http://www.xinhuanet.com/politics/2019-10/25/c_1125153665.htm)

> 习近平在主持学习时发表了讲话。目前，全球主要国家都在加快布局区块链技术发展。我国在区块链领域拥有良好基础，要加快推动区块链技术和产业创新发展，积极推进区块链和经济社会融合发展。
  
> 习近平强调，要强化基础研究，提升原始创新能力，努力让我国在区块链这个新兴领域走在理论最前沿、占据创新制高点、取得产业新优势。要推动协同攻关，加快推进核心技术突破，为区块链应用发展提供安全可控的技术支撑。要加强区块链标准化研究，提升国际话语权和规则制定权。
  
> ......

区块链是对过往技术的重新组合，是现阶段信息科技创新的高潮。区块链 通过一种全新的信任机制--去信任化(Trustless)，使网络中不熟悉的节点间 也可以直接建立信任关系，每个节点有相同的网络权力，不再存在中心化的服 务器，任一节点停止工作都不会影响系统整体的运作。可以说，以往技术带来 的是生产力的提升，而区块链带来的是生产关系的改变。新的生产关系构建带 来的效率、安全提升将对各行业产生深远影响。

作为互联网从业者，我从2018年初正式关注区块链技术的发展，致力于区块链技术与线下实体产业的融合，在学习区块链的过程中会发现很多生涩难懂的术语，于是边学习边整理，故有此书。当然目前此书的目录排版以及内容，可能都不完善或者有其他待商榷的地方，欢迎大家指正，也希望借此能认识更多的同行者。本书仅作为学习参考使用，部分内容来自于网络，如有侵权，请联系作者删除。

胡成武，二〇一九年十一月，于杭州

## 区块链基础

### 1. 起源-不得不提的比特币

比特币（Bitcoin）的概念最初由中本聪在2008年11月1日提出，并于2009年1月3日正式诞生 [1]  。根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的虚拟的加密数字货币。点对点的传输意味着一个去中心化的支付系统。

与所有的货币不同，比特币不依靠特定货币机构发行，它依据特定算法，通过大量的计算产生，比特币经济使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学的设计来确保货币流通各个环节安全性。P2P的去中心化特性与算法本身可以确保无法通过大量制造比特币来人为操控币值。基于密码学的设计可以使比特币只能被真实的拥有者转移或支付。这同样确保了货币所有权与流通交易的匿名性。比特币与其他虚拟货币最大的不同，是其总数量非常有限，具有极强的稀缺性。

具体可以参考比特币白皮书：[比特币:一种点对点的电子现金系统](http://blockchainhandbooks.com/file/比特币白皮书.pdf)

### 2. 基础概念

####        1. 区块与区块链

大家可能都听过姐弟恋、异地恋、就是没听过区块链，今天我们来聊一聊区块链是个什么链？

**区块链**（英语：blockchain或 block chain）是借由密码学串接并保护内容的串连交易记录（又称区块）。每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易数据（通常用默克尔树(Merkle tree)算法计算的散列值表示）

狭义来讲，是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构， 并以密码学方式保证的不可篡改和不可伪造的分布式账本。

广义来讲，是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算方式

可以把区块链理解成一种分布式的交易的共享账本。交易信息将被整理并打包记录在区块中。区块链是一种数据结构，这种结构的数据可以看成是一系列链 接的队列，这些队列通过哈希指针进行关联(与传统意义上的普通指针要区分开， 哈希指针用来指向前一个区块)。

比特币中的链式结构如下:

![](imgs/chain.png)
 
主要分为：公有链、联盟链、私有链

>**公有链/ Public Blockchain**

公有链的任何节点都是向任何人开放的，每个人都可以参与到这个区块链中的计算，而且任何人都可以下载获得完整区块链数据，即全部账本。

>**联盟链/ Consortium Blockchain**

联盟链是指参与每个节点的权限都完全对等，各节点在不需要完全互信的情况下就可以实现数据的可信交换，联盟链的各个节点通常有与之对应的实体机构组织，通过授权后才能加入或退出网络。联盟链是一种公司与公司、组织与组织之间达成联盟的模式。

>**私有链/ Private Blockchain**

在某些区块链的应用场景下，开发者并不希望任何人都可以参与这个系统，因此建立一种不对外公开、只有被许可的节点才可以参与并且查看所有数据的私有区块链，私有链一般适用于特定机构的内部数据管理与审计。

####        2. Merkle Tree
默克尔树（Merkle tree，MT）是一种哈希二叉树，1979年由Ralph Merkle发明。在计算机科学中，二叉树是每个节点最多有两个子树的树结构，每个节点代表一条结构化数据。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现数据快速查询。二叉树如下图所示。

![](imgs/tree.png)

>**1).Merkle树结构**

由一个根节点（root）、一组中间节点和一组叶节点（leaf）组成。叶节点（leaf）包含存储数据或其哈希值，中间节点是它的两个孩子节点内容的哈希值，根节点也是由它的两个子节点内容的哈希值组成。所以Merkle树也称哈希树。

>**2).哈希树的特点**

叶节点存储的是数据文件，而非叶节点存储的是其子节点的哈希值（Hash，通过SHA1、SHA256等哈希算法计算而来），这些非叶子节点的Hash被称作路径哈希值（可以据其确定某个叶节点到根节点的路径）, 叶节点的Hash值是真实数据的Hash值。因为使用了树形结构, 其查询的时间复杂度为 O(logn)，n是节点数量。

![](imgs/hash.png)

默克尔树的另一个特点是，底层数据的任何变动，都会传递到其父节点，一直到树根。

>**3).应用模式**

默克尔树的典型应用场景包括：
* **快速比较大量数据**：当两个默克尔树根相同时，则意味着所代表的数据必然相同（哈希算法决定的）。
* **快速定位修改**：例如上例中，如果 D1 中数据被修改，会影响到Hash0-0，Hash0 和 Root。因此，沿着 Root --> 0 --> 0-0，可以快速定位到发生改变的 D1；
* **零知识证明**：例如如何证明某个数据（D0……D3）中包括给定内容 D0，很简单，构造一个默克尔树，公布 N0，N1，N4，Root，D0拥有者可以很容易检测 D0 存在，但不知道其它内容。
相对于 Hash List，MT的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这个很多使用场合就带来了哈希列表所不能比拟的方便和高效。正是源于这些优点，MT常用于分布式系统或分布式存储中

>**4).在分布式存储系统中的应用原理**

为了保持数据一致，分布系统间数据需要同步，如果对机器上所有数据都进行比对的话，数据传输量就会很大，从而造成“网络拥挤”。为了解决这个问题，可以在每台机器上构造一棵Merkle Tree，这样，在两台机器间进行数据比对时，从Merkle Tree的根节点开始进行比对，如果根节点一样，则表示两个副本目前是一致的，不再需要任何处理；如果不一样，则沿着hash值不同的节点路径查询，很快就能定位到数据不一致的叶节点，只用把不一致的数据同步即可，这样大大节省了比对时间以及数据的传输量。

>**5).比特币中的Merkle Tree**

比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。
在比特币系统中使用Merkle树有诸多优点：首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据，这使得哈希运算可以高效地运行在智能手机甚至物联网设备上；其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。所以，在区块链中使用Merkle树这种数据结构是非常具有意义的。

####        3. 哈希算法

**散列函数**（英语：Hash function）又称**散列算法、哈希函数**，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

![](imgs/hashfun.png)

> **1).确定性(Deterministic)** 

对于同一个输入，无论用哈希函数计算多少次，都会得到相同的结果。
> **2).快速计算** 

对于输入的字符串，能在合理的时间内算出哈希函数的输出，否则会影响系
统的性能。 
> **3).隐秘性**

如果我们已知字符串 A 的哈希值是 H(A)，那么我们没有可行的办法算出 A 是什么。注意，这里说的是 “不可行” 而不是 “不可能”。
在已知哈希值的情况下， 尽管可以通过暴力破解的方法找到输入的字符串 是什么，但这会花费很长长长长长的时间，所以不用担心。

> **4).抗篡改能力** 

对于任意一个输入，哪怕是很小的改动，其哈希改变也会非常大。

> **5).抗碰撞能力** 

碰撞是指，对于相同的输入，经过哈希计算后产生了不同的输出。具有抗碰撞能力就是对于大部分的输入都有独一无二的输入。 这里说的是”大部分”， 因为找不到碰撞，并不意味不存在碰撞。
但对于 SHA -256 之类的哈希函数，需要花费很长的时间来找到碰撞。所以 我们完全可以认为 if H(A) = H(B) 那么 A=B.

**非对称加密**

非对称加密算法是一种密钥的保密方法。非对称加密算法需要两个密钥:公 开密钥(publickey)和私有密钥(privatekey)。 公开密钥与私有密钥是一对， 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密;如果用私有 密钥对数据进行加密，那么只有用对应的公开密钥才能解密。

![](imgs/encrypt.png)

```
1)、A 要向 B 发送信息、A 和 B 都要生成一对用于加密和解密的公钥和私 钥
2)、A 的私钥保密，A 的公钥告诉 B;B 的私钥保密，B 的公钥告诉 A。 
3)、A 要给 B 发送信息时，A 用 B 的公钥加密信息，因为 A 知道 B 的公钥。 
4)、A 将这个消息发给 B(已经用 B 的公钥加密消息)。
5)、B 收到这个消息后，B 用自己的私钥解密 A 的消息。其他所有收到这个报文的人都无法解密，因为只有 B 才有 B 的私钥。
```
####        4. 分叉、孤块与叔块

**分叉**含有数个定义：
* 一条区块链分开成两条区块链
* 一个协议的改变或两个区块拥有相同的高度

分叉可分为**意外分叉**和**有意分叉**。

>**意外分叉**

当两个或以上的矿工在几乎相同的时间成功挖到区块，便会出现意外分叉。 此时，矿工便会分别在两条分叉上各自挖矿，直至其中一条分叉比其他分叉更长。（这代表矿工对采纳哪一个分叉已达成共识）因此，矿工网络随后便会放弃挖掘其他分叉。被抛弃的区块被称为孤立区块。因此，不少密码货币使用者，均要求交易需要多次确认，以防止意外分叉使交易所在之区块变为无效。

>**有意分叉**

有意分叉则对原区块链作出修改，可再分类如下：
新版本和旧版本中的区块能够相互兼容，称为“软分叉”，不能相互兼容就称为“硬分叉”。

* 硬分叉

硬分叉之中新分叉所产生之区块将被旧软件视为无效。因此所有参与者，包括交易服务器以及矿工（节点），都必须更新软件，才能继续运行新分叉。[4]如有节点组继续使用旧软件，而其他节点使用新的软件，便有可能产生分裂成两只货币。

* 软分叉

与硬分叉相比，软分叉所产生之区块能够被旧软件识别为有效区块，即区块 向下兼容。然而，旧软件所产生之区块则未必在新规则下有效。

**孤块(orphan block)**：在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块是一个块，它也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。

而在以太坊中，不能跻身主链的区块都是孤块，如果这些孤块能够被后来的区块通过Uncle字段收留，则这些孤块会成为叔块

**“叔块”(uncle block)**：Ethereum的GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。在以太坊中，孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献。
叔块的奖励计算有些复杂，公式为：
```
叔块奖励 = ( 叔块高度 + 8 - 包含叔块的区块的高度 ) * 普通区块奖励 / 8
```

####        5. 分布式、P2P、非对称加密
> **0).点对点/ Peer-to-Peer / P2P**

通过允许单个节点与其他节点直接交互，无需通过中介机构，从而实现整个系统像有组织的集体一样运作的系统。

> **1).去中心化**

去中心化是互联网发展过程中形成的社会关系形态和内容，是相对于“中心化”而言的新型网络内容的生产过程。在计算机技术领域，去中心化结构使用分布式核算和存储，不存在中心化的节点，任意节点的权利和义务都是均等的，系统中的数据块由整个系统中具有维护功能的节点来共同维护，任一节点停止工作都不会影响系统整体的运作。

> **2).分布式**

分布式网络存储技术是将数据分散的存储于多台独立的机器设备上。分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，不但解决了传统集中式存储系统中单存储服务器的瓶颈问题，还提高了系统的可靠性、可用性和扩展性，这种组织方式能有效提升信息的传递效率。

> **3).两者的异同**

下图能够很好地反映“中心化”、“去中心化”、“分布式”、“点对点”的异同。

![](imgs/distributed.png)

关于“去中心化”和“分布式”的区别大概可以总结为：去中心化是分布式网络结构中的一种，所有的去中心化都是采用分布式网络结构的，而分布式网络结构可能是“中心化”也可能是“去中心化”的。

**去中心化**：相对于“中心化”概念，在去中心化的系统网络里，每一个参与者（节点）都是平等且自由的关系，没有谁依赖谁。

**多中心化**：和去中心化有一些相近， 由多个中心节点组成的平等网络，节点的参与和退出可能有所要求和限制。

**分布式**：分布也可以说分散，节点是分散的，分布式的网络节点之间互联互通，当任何一个节点出现故障时其它节点仍然能够继续工作。

####        6. UXTO模型、账户余额模型

> **1).UTXO**

**UTXO （ Unspent Transaction Output）**，直接翻译出来的意思是“未花费的输出”，在比特币系统里，没有设计使用交易者账户系统，而是记录一笔又一笔的交易，而且交易输入（资金来源，包括挖矿所得）=交易输出（即UTXO）+矿工费，比特币就在一个接一个的交易输入与输出中流动起来。
由挖矿所得创建的比特币交易，是每个区块中的首个交易，又称之为coinbase交易，它由矿工创建，没有上一笔交易输出。
在比特币交易中 UTXO 就是基本单位，一个UTXO一旦被创建就不可被继续分割，它只能当作是下一笔交易的输入被花费掉，花费后产生新的UTXO，这样周而复始地实现货币的价值转移。所以我们在比特币钱包中所看到的账户余额，实际上是钱包通过扫描区块链并聚合所有属于该用户的UTXO计算得来的。
比特币的UXTO系统遵守两个规则：
* 1、 除了 CoinBase（挖矿交易）之外，所有的资金来源都必须来自前面某一个或者几个交易的UXTO；
* 2、任何一笔交易的输入总量必须等于输出总量，等式两边必须配平。

>**2).账户余额**

**账户/余额模型**会将每个账户的余额保持为全球状态。 检查帐户的余额以确保其大于或等于支出交易金额。

>**3).优缺点**

**UTXO模型**的好处是：


* **可扩展性** - 由于可以同时处理多个UTXO，因此可以实现并行事务并鼓励可伸缩性创新。
* **隐私** - 甚至比特币也不是一个完全匿名的系统，但只要用户为每笔交易使用新地址，UTXO就可以提供更高级别的隐私。 如果需要增强隐私性，可以考虑更复杂的方案，例如环签名。

**账户/余额模型**的好处是：

* **简单性** - 以太坊选择了一种更直观的模式，以便为复杂智能合约的开发人员带来益处，尤其是那些需要国家信息或涉及多方的开发人员。 一个例子是一个智能合约，跟踪各国根据它们执行不同的任务。 UTXO的无状态模型会迫使交易包含状态信息，这不必要地使合约的设计复杂化。
* **效率** - 除了简单之外，账户/余额模型更加高效，因为每笔交易只需要验证发送账户是否有足够的余额来支付交易。


###    3. 发展阶段
```
区块链的进化方式是：
▪ 区块链1.0——数字货币
▪ 区块链2.0——智能合约（可编程区块链）
▪ 区块链3.0——分布式社会（可编程商业经济）
```

> **1. 技术实验阶段（2007—2009）**

化名中本聪的比特币创始人从2007年开始探索用一系列技术创造一种新的货币——比特币，2008年10月31日发布了《比特币白皮书》，2009年1月3日比特币系统开始运行。

> **2. 极客小众阶段（2010-2012）**

2010年2月6日诞生了第一个比特币交易所，5月22日有人用10000个比特币购买了2个披萨。2010年7月17日著名比特币交易所Mt.gox成立，这标志着比特币真正进入了市场。

> **3. 市场酝酿阶段（2013-2015）**

2013年初比特币价格13美元，3月18日金融危机中的塞浦路斯政府关闭银行和股市，推动比特币价格飙升，4月最高至266美元。8月20日德国政府确认比特币的货币地位。10月14日中国百度宣布开通比特币支付。11月美国参议院听证会明确了比特币的合法性。11月19日比特币达到1242美元新高！

> **4. 进入主流阶段（2016-2018）**

世界主流经济不确定性增强，具有避险功能从而与主流经济呈现替代关系的比特币开始复苏，尽管中国市场受到政策的严厉遏制，但韩国、日本、拉美等市场快速升温，比特币价格从2016年初的400美元最高飙升至2017年底的20000美元，翻了50倍。

> **5. 产业落地阶段（约2019-2021）**

在市场狂乱之后，2018年的虚拟货币和区块链会在市场、监管、认知等各方面进行调整，回归理性。

> **6、产业成熟阶段（约2022-2025）**

各种区块链项目落地见效之后，会进入激烈而快速的市场竞争和产业整合阶段，三五年内形成一些行业龙头，完成市场划分，区块链产业格局基本形成，相关法律法规基本健全，区块链对社会经济各领域的推动作用快速显现，加密货币将成为主流货币，经济理论会出现重大调整，社会政治文化也将发生相应变化，国际政治经济关系出现重大调整，区块链在全球范围内对人们的生活产生广泛而深刻的影响。

###    4. 特性
####        1. 去中心化
以太坊创始人Vitalik Buterin于2017年2月发表的《The meaning of decentralization》一文中，详细阐述了去中心化的含义。他认为应该从三个角度来区分计算机软件的中心化和去中心化：**架构、治理和逻辑。**

* **架构中心化**是指系统能容忍多少节点的崩溃而可以继续运行；
* **治理中心化**是指需要多少的个人和组织能最终控制这个系统；
* **逻辑中心化**是指系统呈现的接口和数据是否像是一个单一的整体。

区块链是全网统一的账本，因此从逻辑上看是中心化的，这一点无可置疑。从架构上看，区块链是基于对等网络的，因此是架构去中心化的。从治理上看，区块链通过共识算法使得少数人很难控制整个系统，因此是治理去中心化的。架构和治理上的去中心化为区块链带来三个好处：容错性、抗攻击力和防合谋。

> **“去中心化”不等于去监管**

人们之所以试图否认区块链的“去中心化”特征，或许是因为错误地认为去中心就是要去监管。其实并非如此。监管与“去中心化”并不冲突，“去中心化”去的是中央控制方和中介方，而不是监管方。

区块链技术从来就不排斥监管，监管节点可以方便地接入任何一个区块链网络。由于区块链的公开透明特性，监管机构反而可以更加方便地监控整个系统的交易数据，而且由于区块链的防篡改特性，交易一旦发生后即不可更改、不可删除，那种数据造假蒙蔽监管的情况就不可能发生了，更有利于监管机构对市场行为进行监督。由此可见，区块链将成为监管科技（RegTech）的重要工具。

中心和去中心的概念推广到社会体制，就是**集权和民主。**

####        2. 匿名性

> **区块链从来都不是匿名的，而是非实名的**

匿名是指每个人的身份是无法被人知道的，而非实名是指每个人在区块链上有一个和真实身份无关的虚拟身份，但是这个虚拟身份做的所有事情都是透明的。

区块链的匿名性本身是一个功能点，并不是不可分割的特性，是否必要取决于实际需求。

当然，当前的数字货币的匿名性初衷在于保护隐私，毕竟去中心化的模式决定了数据公开透明，而公开透明直接导致隐私问题，所以采用匿名的形式。而且仅仅是一定程度上的“伪匿名”，或者说maxdeath所说的非实名。

在实际商业应用落地的过程当中，匿名性本身是会导致一系列问题的。尤其在商务合作中，绝对是无法完全匿名的，会导致信任构建的困难。毕竟不是说应用了区块链就能轻易的建立商业层面的信任的。

另外，审查监管需求也是实际运作中不可忽略的一块，完全去第三方的理想主义在现实应用中是行不通的，区块链仅仅保障了线上数据的不可篡改真实可信，落到线下的承兑环节，还是需要政府法律来保障执行，监管显然是于情于理都需要考虑的，而对于政府机构而言，**AML及KYC**是绕不开的，显然也是实名的需求。

```
注：AML|KYC  客户知情权(KYC)和反洗钱(AML)法律
```

当然了，如果是在无关商业行为的领域，或者应用场景中没有那么多的审查监管需求，匿名性是可以保留的，或者是有一定需求的。

然后回到上面说的隐私保护的问题，在那个帖子的讨论中也有提到，如果匿名或者非实名仅仅是一种保护隐私的手段，那么完全可以采用其他手段来保护隐私，比如说数据加密仅对特定授权节点开放权限（当然监管方可以获得更高的权限），这就是操作层面的事情了。


####        3. 不可篡改

```
技术维度：利用强大的加密算法和巧妙的数据结构确保每个修改都会被检测到；
经济维度：利用工作量证明使得每次修改都需要付出巨大的经济成本。
```

> **1).加密算法SHA256**

一种国际公认的优秀加密算法，输入是任意长度的数据，输出总是256位的值，这个值通常我们称之为哈希值，输入值的任何微小的变化都会产生不同的输出。

> **2.数据结构默克尔树**

一种树状数据结构，比特币的区块链使用了二叉树，这个二叉树的每个节点都对应一个哈希值：最底层的节点是每笔交易的哈希，第二层的每个节点都是它下方两个哈希拼接后经过SHA256算法后生成的哈希，依次类推直到最顶端只剩一个节点，我们称这个节点为梅克尔根。
回顾下SHA256算法的特性，任何微小的输入变动都会引起输出值剧烈的变化。也就是说，交易记录中的任何变化，哪怕只把输出值增加了1聪，都会引起那次交易哈希翻天覆地的变化，这个变化会影响到第二级的哈希，进而一级一级顺着梅克尔树传递到梅克尔根。
由于区块拥有了这样的组织结构，区块内部的任何交易信息的改动，总会引起梅克尔树根的哈希值变化，进而包含了梅克尔根的区块头会发生变化，最终导致区块头的哈希发生变化

> **3.工作量证明与分布式账本**

你可能还记得区块头的哈希值这个概念，区块链技术对这个256位哈希值会有一个要求，就是这个值必须小于某个上限。回顾SHA256这个算法的概念，你会发现，输出的哈希值是非常随机的，如果需要把结果落入特定的范围，需要不停的修改输入进行尝试，直到输出满足要求。在区块链中，在区块的头部有一个32位的随机量可以修改，以完成调整最终哈希的目的。
当前，满足小于这个上限值要求的难度有多大呢？一个专用的顶级矿机（一种专门用来计算哈希的计算设备），需要平均工作14个月才能找到一个合适的目标哈希。每修改一个区块，中间消耗的电量和时间估计都会超出被修改的账单中的获益，更不用说还需要修改很多个。
甚至，这个修改完成后，还有一个更艰巨的任务，就是黑掉全世界51%以上的区块链备份电脑。否则，即使你的账本修改的很完美，但是跟其他大部分人的不一致，那这个修改也毫无作用。
那么，篡改交易信息的意义又是什么？


####        4. 去信任
中本聪在比特币白皮书中提出[我们提出了一个不依赖中介信任的电子交易系统。]()他指的是区块链，比特币加密货币背后的系统。规避信任是一个伟大的承诺 , 但事实并非如此。是的，比特币消除了信用卡等其他支付系统所固有的某些可信的中介。但你仍然要相信比特币 —— 以及它的一切。

许多人把区块链描述为一种无需信任的系统。在我看来，“无需信任”这个词是含糊不清的，最重要的是，对于区块链来说，这个词是不准确的。

**区块链实际上并没有消除信任，整个区块链系统所要做的就是减少系统中每个单个参与者所需要的信任量。** 区块链系统通过激励机制来保证每个参与者之间按照系统协议来合作，从而实现把信任分配给每个参与者。

严格来说，**区块链确实实现了“去信任化”，或者“去基于人的信任化”，换个角度说，区块链实现的是“基于代码的信任”。** 这种基于代码的信任，是100%的，一旦代码经过一次验证之后（因为写代码的还是人），面向的交互对象就没有人的因素在里面了，只有代码。这种信任模型是开创性质的，能够从底层深刻地改变社会运行关系。在区块链技术之前，我们整个社会没有100%的代码信任模型，我们信任微信支付，本质上是信任腾讯公司；我们存钱进银行，本质上是信任银行公司；我们相信我们买到的股票真的是股票，是因为信任国家担保的交易所以及法律体系。我们整个社会的运行，有大量的信任模型，其实依赖于信任个人、公司、组织、政府，以及人与人之间的互相制约和担保、公证、法律法规、程序等一系列明规则、潜规则，以及这些信任因素之间的组合。比如我们相信购买的股票真的是股票，这一份信任的来源组成=50%政府担保的公司法和交易所+20%第三方银行资金监管+20%公司品牌声誉+10%各种审查审计和监管=100%的信任；即我们相信买到的股票真的是股票。如果去掉其中一个因素，那么这份信任就会打折扣，运行起来会有人不放心，进而影响了交互的规模扩大，以及产生了中间协调（仲裁）的消耗。这里面其实也有代码信任的成分，比如交易所平台就是靠代码自动运行的，但是它占的比重不大，因为这份代码是可以人为干预的，所以我们更多的是信任来源是这个交易所平台的管理机构。

区块链技术，提供了一种新的解决模型，即“100%基于代码的信任模型”，没有任何人为的其他信任因素存在，完全机器化的信任模型。我们知道，计算机也是控制在人手上的，怎么做到控制计算机的人没法干预计算机的运行？区块链技术其实采用了点对点的通讯技术和配套机制，通过分散部署成千上万的计算机节点，然后这些离散化的节点互相自动化监督，这里面的配套机制确保，这成千上万的节点无法串通起来，并且在逻辑上可以论证，构筑其极高的防作弊壁垒。

####        5. 开放性

长久以来，去中心化是区块链被人们提到最多的特性，除了去中心化之外，区块链还有一个特性就是开放性，比较少被提到，但它也很重要，甚至可以说**开放性是去中心化特性的保证之一。**

当人们提起区块链开放性的时候，有各种各样的说法，有人说区块链经济就是开源经济，有人说是区块链是最伟大之处是无需许可的创新协议，有人说区块链最有价值的地方在于开放金融，还有人说区块链改变了传统的公司制组织结构，它创造了一种新的基于通证的经济体系，在这种经济体系下可以使得传统的封闭公司变成一个开放的通证形态，使得人类的大规模强协作成为可能。

目前来看，区块链的开放性主要体现在以下几个方面：**第一个是账目的开放性，即所有历史交易记录对外公开；第二个是组织结构的开放性，所有持有 Token 的都可以称之为币东；第三个是生态的开放性。**

听起来都很厉害，但是其实理解起来还是挺困难的，所以我把这几个跟“开放性”有关的话题都整理在一起，简单的梳理一下。

**所谓开放性，就是所有人都可以自由加入区块链，并得到所有信息，整个系统高度透明，只有各方的私有信息是加密的。**

**拿比特币网络来说，比特币网络在系统层面上信息完全公开，各个成员可以借助各种字符实现信息公开的同时保证信息的安全。** 这就决定了区块链系统是开放的，除了交易各方的私有信息被加密外，区块链的数据对所有人公开，任何人都可以通过公开的接口查询区块链数据和开发相关应用，让整个系统信息高度透明。

## 区块链技术
###    1. 共识算法

在谈共识算法之前，先聊聊分布式系统的几个术语

> **分布式一致性**

一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。在一个分布式系统中，如何保证集群中所有节点中的数据完全相同并且能够对某个提案（Proposal）达成一致

> **CAP（一致性、可用性和分区容错性）**

首先是在异步的网络模型中，所有的节点由于没有时钟仅仅能根据接收到的消息作出判断，这时完全不能同时保证一致性、可用性和分区容错性，每一个系统只能在这三种特性中选择两种。

> **FLP**

FLP 不可能定理是分布式系统领域最重要的定理之一，它给出了一个非常重要的结论：在网络可靠并且存在节点失效的异步模型系统中，不存在一个可以解决一致性问题的确定性算法。

> **共识算法**

**共识机制用于解决分布式系统的一致性问题，其核心为在某个协议(共识算法)保障下，在有限的时间内，使得指定操作在分布式网 络中是一致的、被承认的、不可篡改的。** 在区块链系统中，特定的共 识算法用于解决去中心化多方互信的问题。

按照不同的故障类型，共识算法可分为两类情况。

一类使用数学 上及工程学上的方式，确保各个节点之间的数据绝对一致，通常用于 解决可信节点间的网络通信故障问题，常用算法包括 Paxos、Raft、 ZAB 等，常见于大数据分布式系统，这些算法不具备对不可信节点的 容错性。这类算法也包括用于解决拜占庭将军问题的拜占庭容错算法 (BFT)等，该算法允许有一定比例的不可信节点。

另一类共识算法则通过经济利益的博弈，来鼓励对系统的贡献及 提高不可信节点的作恶成本。常用算法包括工作量证明(Proof of Work, PoW)、权益证明(Proof of Stake, PoS)等，PoW、PoS 算法分 别通过提供算力或持有权益来平衡利益博弈
####        1. POW、POS、DPOS

> **POW(Proof-of-Work)**

工作量证明（POW，Proof-of-Work）是一个用于阻止拒绝服务攻击和类似垃圾邮件等服务错误问题的协议。
布式系统中的请求服务的节点必须解决一个一般难度但是可行（feasible）的问题，但是验证问题答案的过程对于服务提供者来说却非常容易，也就是一个不容易解答但是容易验证的问题。

> **POS(Proof-of-Stake)**

权益证明是区块链网络中的使用的另一种共识算法，在基于权益证明的密码货币中，下一个区块的选择是根据不同节点的股份和时间进行随机选择的。

> **DPOS(Delegated Proof-of-Stake)**

在委托权益证明中，每一个参与者都能够选举任意数量的节点生成下一个区块，得票最多的前 N 个节点会被选择成为区块的创建者，下一个区块的创建者就会从这样一组当选者中随机选取，除此之外，N 的数量也是由整个网络投票决定的，所以可以尽可能地保证网络的去中心化。

####        2. Paxos
Paxos算法是Lamport宗师提出的一种基于消息传递的分布式一致性算法。

Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。

Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。

一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。

Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):

* **Proposer:** 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
* **Acceptor：** 参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
* **Learner：** 不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。

![](imgs/paxos-1.png)

> **1).Paxos算法中的角色**

Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：

* 第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。
* 第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。
* 第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。

![](imgs/paxos-2.png)

> **2).Paxos算法流程**

Paxos算法流程中的每条消息描述如下：

* **Prepare:** Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。
* **Promise:** Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。

**两个承诺：**

* 不再接受Proposal ID小于等于（注意：这里是<= ）当前请求的Prepare请求。
* 不再接受Proposal ID小于（注意：这里是< ）当前请求的Propose请求。

**一个应答：**

不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。

* **Propose:** Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。
* **Accept:** Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。
* **Learn:** Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。


####        3. PBFT

**PBFT（Practical Byzantine Fault Tolerance）拜占庭容错**

PBFT 算法的提出主要是为了解决拜占庭将军问题。什么是拜占庭将军问题呢？拜占庭位于如今的土耳其的伊斯坦布尔，是古代东罗马帝国的首都。拜占庭罗马帝国国土辽阔，为了达到防御目的，每块封地都驻扎一支由将军统领的军队，每个军队都分隔很远，将军与将军之间只能靠信差传递消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定影响将军们达成一致共识。在已知有将军是叛徒的情况下，其余忠诚的将军如何达成一致协议的问题，这就是拜占庭将军问题。
要让这个问题有解，有一个十分重要的前提，那就是信道必须是可靠的。如果信道不能保证可靠，那么拜占庭问题无解。

> **算法基本流程**

PBFT算法的基本流程主要有以下四步：

* 客户端发送请求给主节点 
* 主节点广播请求给其它节点，节点执行 pbft 算法的三阶段共识流程。
* 节点处理完三阶段流程后，返回消息给客户端。
* 客户端收到来自 f+1 个节点的相同消息后，代表共识已经正确完成。

为什么收到 f+1 个节点的相同消息后就代表共识已经正确完成？从上一小节的推导里可知，无论是最好的情况还是最坏的情况，如果客户端收到 f+1 个节点的相同消息，那么就代表有足够多的正确节点已全部达成共识并处理完毕了。

> **算法核心三阶段流程**

基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：

![](imgs/pbft.png)

首先，客户端向主节点发起请求，主节点 0 收到客户端请求，会向其它节点发送 pre-prepare 消息，其它节点就收到了pre-prepare 消息，就开始了这个核心三阶段共识过程了。
* **Pre-prepare 阶段**：节点收到 pre-prepare 消息后，会有两种选择，一种是接受，一种是不接受。什么时候才不接受主节点发来的 pre-prepare 消息呢？一种典型的情况就是如果一个节点接受到了一条 pre-pre 消息，消息里的 v 和 n 在之前收到里的消息是曾经出现过的，但是 d 和 m 却和之前的消息不一致，或者请求编号不在高低水位之间（高低水位的概念在下文会进行解释），这时候就会拒绝请求。拒绝的逻辑就是主节点不会发送两条具有相同的 v 和 n ，但 d 和 m 却不同的消息。
* **Prepare 阶段**：节点同意请求后会向其它节点发送 prepare 消息。这里要注意一点，同一时刻不是只有一个节点在进行这个过程，可能有 n 个节点也在进行这个过程。因此节点是有可能收到其它节点发送的 prepare 消息的。在一定时间范围内，如果收到超过 2f 个不同节点的 prepare 消息，就代表 prepare 阶段已经完成。
* **Commit 阶段**：于是进入 commit 阶段。向其它节点广播 commit 消息，同理，这个过程可能是有 n 个节点也在进行的。因此可能会收到其它节点发过来的 commit 消息，当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。

根据上述流程，在 N ≥ 3F + 1 的情況下一致性是可能解決，N为总计算机数，F为有问题的计算机总数

对于 pbft 算法，因为 pbft 算法的除了需要支持容错故障节点之外，还需要支持容错作恶节点。假设集群节点数为 N，有问题的节点为 f。有问题的节点中，可以既是故障节点，也可以是作恶节点，或者只是故障节点或者只是作恶节点。那么会产生以下两种极端情况：

* 第一种情况，f 个有问题节点既是故障节点，又是作恶节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。也就是说这种情况支持的最大容错节点数量是 （n-1）/2。
* 第二种情况，故障节点和作恶节点都是不同的节点。那么就会有 f 个问题节点和 f 个故障节点，当发现节点是问题节点后，会被集群排除在外，剩下 f 个故障节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。所以，所有类型的节点数量加起来就是 f+1 个正确节点，f个故障节点和f个问题节点，即 3f+1=n。

结合上述两种情况，因此**PBFT算法支持的最大容错节点数量是（n-1）/3。**


####        4. Raft

> **RAFT**

RAFT核心思想很容易理解，如果数个数据库，初始状态一致，只要之后的进行的操作一致，就能保证之后的数据一致。由此RAFT使用的是Log进行同步，并且将服务器分为三中角色：Leader，Follower，Candidate，相互可以互相转换。

RAFT从大的角度看，分为两个过程：

* 选举Leader
* Leader生成Log，并与Follower进行Headbeats同步

> **选举Leader**

Follower自增当前任期，转换为Candidate，对自己投票，并发起RequestVote RPC，等待下面三种情形发生；
* 获得超过半数服务器的投票，赢得选举，成为Leader
* 另一台服务器赢得选举，并接收到对应的心跳，成为Follower
* 选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举

> **同步日志**

Leader接受客户端请求，Leader更新日志，并向所有Follower发送Heatbeats，同步日志。所有Follwer都有ElectionTimeout，如果在ElectionTimeout时间之内，没有收到Leader的Headbeats，则认为Leader失效，重新选举Leader

> **安全性保证**

* 日志的流向只有Leader到Follower，并且Leader不能覆盖日志
* 日志不是最新者不能成为Candidate

[动画演示RAFT](http://thesecretlivesofdata.com/raft/)


####        5. Ripple
**Ripple（瑞波）是一种基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。** 在Ripple的网络中，交易由客户端（应用）发起，经过追踪节点（tracking node）或验证节点（validating node）把交易广播到整个网络中。追踪节点的主要功能是分发交易信息以及响应客户端的账本请求。验证节点除包含追踪节点的所有功能外，还能够通过共识协议，在账本中增加新的账本实例数据。　　

Ripple的共识达成发生在验证节点之间，每个验证节点都预先配置了一份可信任节点名单，称为UNL（Unique Node List）。在名单上的节点可对交易达成进行投票。每隔几秒，Ripple网络将进行如下共识过程：
* 1).每个验证节点会不断收到从网络发送过来的交易，通过与本地账本数据验证后，不合法的交易直接丢弃，合法的交易将汇总成交易候选集（candidate set）。交易候选集里面还包括之前共识过程无法确认而遗留下来的交易。
* 2).每个验证节点把自己的交易候选集作为提案发送给其他验证节点。
* 3).验证节点在收到其他节点发来的提案后，如果不是来自UNL上的节点，则忽略该提案；如果是来自UNL上的节点，就会对比提案中的交易和本地的交易候选集，如果有相同的交易，该交易就获得一票。在一定时间内，当交易获得超过50%的票数时，则该交易进入下一轮。没有超过50%的交易，将留待下一次共识过程去确认。　　
* 4).验证节点把超过50%票数的交易作为提案发给其他节点，同时提高所需票数的阈值到60%，重复步骤3）、步骤4），直到阈值达到80%。
* 5).验证节点把经过80%UNL节点确认的交易正式写入本地的账本数据中，称为最后关闭账本（Last Closed Ledger），即账本最后（最新）的状态。

Ripple共识过程节点交互示意图
![](imgs/ripple-1.png)

Ripple共识算法流程
![](imgs/ripple-2.png)

在Ripple的共识算法中，参与投票节点的身份是事先知道的，因此，算法的效率比PoW等匿名共识算法要高效，交易的确认时间只需几秒钟。当然，这点也决定了该共识算法只适合于权限链（Permissioned chain）的场景。**Ripple共识算法的拜占庭容错（BFT）能力为（n-1）/5**，即可以容忍整个网络中20%的节点出现拜占庭错误而不影响正确的共识。


####       6. Kafka、SOLO
SOLO模式只有一个order服务节点负责接收交易信息并排序，这是最简单的一种排序算法，不适合大规模的实际生产环境，一般用在实验室测试环境中。

[Kafka入门介绍](https://lotabout.me/2018/kafka-introduction/)

[Kafka官方中文文档](http://kafka.apachecn.org/)

[Fabric Kafka入门](https://segmentfault.com/a/1190000019012700)

####        7. POF、POC
POF（Proof-of-Formulation）分解Fleta的公式证明
POC（Proof-of-Capacity）容量证明
###    2. 智能合约

智能合约又称智能合同，是由事件驱动的、具有状态的、获得多方承认的、 运行在区块链之上的、且能够根据预设条件自动处理资产的程序，智能合约最大 的优势是利用程序算法替代人仲裁和执行合同。

简单说，**智能合约是一种用计算机语言取代法律语言去记录条款的合约**。智能合约可以由一个计算系统自动执行的传统合约的数字化版本。

与传统的合约相比，智能合约有三大特点:**数据透明、不可篡改、永久运行**。

> **数据透明**

区块链上所有的数据都是公开透明的，因此智能合约的数据处理也是公开透明的，运行时任何一方都可以查看其代码和数据。 

> **不可篡改**

区块链本身的所有数据不可篡改，因此部署在区块链上的智能合约代码以及 运行产生的数据输出也是不可篡改的，运行智能合约的节点不必担心其他节点恶 意修改代码与数据。

> **永久运行**

支撑区块链网络的节点往往达到数百甚至上千，部分节点的失效并不会导致 智能合约的停止，其可靠性理论上接近于永久运行，这样就保证了智能合约能像 纸质合同一样每时每刻都有效。
###    3. 高频协议
####        1. BIP32、BIP39、BIP44
```
**BIP 全名是 Bitcoin Improvement Proposals，是提出 Bitcoin 的新功能或改进措施的文件**。可由任何人提出，经过审核后公布在 bitcoin/bips 上。BIP 和 Bitcoin 的关系，就像是 RFC 之于 Internet。
而其中的 BIP32, BIP39, BIP44 共同定义了目前被广泛使用的 HD Wallet，包含其设计动机和理念、实作方式、实例等。
```
> **BIP32**

BIP32：定义 Hierarchical Deterministic wallet (简称 "HD Wallet")，是一个系统可以**从单一个 seed 产生一树状结构储存多组 keypairs（私钥和公钥）**。好处是可以方便的备份、转移到其他相容装置（因为都只需要 seed），以及分层的权限控制等。
BIP32 定义的 HD Wallet

> **BIP39**

BIP39：**将 seed 用方便记忆和书写的单字表示**。一般由 12 个单字组成，称为 mnemonic code(phrase)，中文称为助记词或助记码。例如：

```
rose rocket invest real refuse margin festival danger anger border idle brown
```
> **BIP44**

BIP44：基于 BIP32 的系统，赋予树状结构中的各层特殊的意义。**让同一个 seed 可以支援多币种、多帐户等**。各层定义如下：
```
m / purpose' / coin_type' / account' / change / address_index
```
其中的 purporse' 固定是 44'，代表使用 BIP44。而 coin_type' 用来表示不同币种，例如 Bitcoin 就是 0'，Ethereum 是 60'。


####        2. ERC-20、ERC-721

这两个词语主要是以太坊上的代币标准。其中官方标准：[ERC-20](https://eips.ethereum.org/EIPS/eip-20)、[ERC-721](https://eips.ethereum.org/EIPS/eip-721)

> **ERC-20**

ERC-20是最广为人知的标准，**ERC-20标准里没有价值的区别，Token之间是可以互换的**。这就相当于说在ERC-20标准下，你的100块“钱”和我的100块“钱”是一样的。

ERC-20标准里规定了Token需要有它的名字、符号、总供应量以及包含转账、汇款等其他功能。这个标准带来的好处是：**只要Token符合ERC-20标准，那么它将兼容以太坊钱包**。也就是说，你可以在你的以太坊钱包里加入这个Token，还可以通过钱包把它发送给别人。

正因为ERC-20标准的存在，使得发行Token变得很简单。目前，以太坊上ERC-20 Token的数量超过了180000种。

> **ERC-721**

既然ERC-20那么厉害，为什么还要多出一个ERC-721标准呢？前面提到ERC-20标准的Token没有价值的区别，那对于一些需要有独一无二属性的资产（比如加密收藏品、游戏道具）便不再适用。

ERC-721标准规定了符合它这种标准的每个Token都有唯一的Token ID。**在ERC-721标准里，每个Token都是独一无二的**。也就是说，在ERC-721标准下，你的100块“钱”和我的100块“钱”是不一样的，因为这两张100块钱的编号是不一样的。

> **异同**

**ERC-20标准的Token是没有价值区分的，是可以互换的；ERC-721标准的Token是不可以互换的，每个Token都有唯一的ID**。

**ERC-20标准的Token是可以分割的，而ERC-721标准的Token是不可以分割的**。


###    4. 扩展性
####        1. 侧链（多条独立链）
####        2. 超大区块（增加区块容量）
####        3. 双层网络（channels和plasma）
####        4. 分片
####        5. 跨链
#####            1. 侧链
#####            2. 中继
#####            3. 公证人
#####            4. 哈希锁定
####        6. 其他
#####            1. 隔离见证
#####            2. DAG有向无环图
#####            3. 闪电网络
#####           4. 雷电网络
####        7. 链上扩容、链下扩容
###    5. 安全
####        1. 多重签名
####        2. 环签名
###    6. 隐私保护
####        1. 混币
####        2. 环签名
####        3. 同态加密
####        4. 零知识证明
####        5. 多方安全计算
###    7. 其他术语
####        1. IPFS
####        2. 石墨烯
####       3. DeFi
 
## 主要链
###    1. 比特币
###    2. 以太坊
###    3. EOS
###    4. HyperLedger Fabric
###    5. 其他区块链
####        1. EOS Force
####        2. Bytom
####        3. NEO
####        4. QTUM
####        5. GXChain
####        6. BAT
####        7. R3 CEV、R3 ChinaLedger
## 应用场景
###    1. 防伪溯源
###    2. 农业、医药
###    3. 司法、政务
###    4. 电子票据
###    5. 版权保护
###    6. 金融
####        1. 证券
####        2. 保险
####        3. 供应链金融
####        4. 支付清算
## 发展趋势
## 风险
###    1. 量子计算
###    2. 分叉：信任危机

## 关于作者
[胡成武]() 非主流程序员、区块链技术与应用践行者、房产投资人。

## 鸣谢

## 尾声
> 看了这么多，区块链是否真的那么深不可测呢？本书源码托管在github，您可以点击网页右上角的logo进入，欢迎大家star并提PR。
